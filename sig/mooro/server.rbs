module Mooro
  class TerminateServer < StandardError
  end

  class Server
    @host: String

    @port: Integer

    @max_connections: Integer

    @stdlog: IO

    @shutdown: bool

    @logger: Ractor

    @workers: Array[Ractor]

    @supervisor: Thread

    def initialize: (Integer max_connections, ?::String host, ?::Integer port, ?IO stdlog) -> void

    # Start the server. If all goes well, the TCPServer socket is guaranteed
    # to be open when this method returns. If some error occurs, an error will
    # be thrown
    def start: () -> void

    def stop: () -> void

    def running?: () -> bool

    def serve: (untyped socket, untyped logger, untyped resources) -> untyped

    # Create a logger Ractor
    # workers & supervisor ----> logger
    #
    # The logger logs messages to @stdlog with the timestamp of when the
    # message was processed
    # Workers and the supervisor will send messages to logger (push based)
    #
    # Termination:
    # Logger only yields once when it terminates. Do not take from it unless
    # joining - the taking thread will hang otherwise
    def make_logger: (?ractor_name: ::String) -> Ractor

    def make_worker_pool: () -> Array[Ractor]

    # Create a worker Ractor
    # supervisor >---- worker ----> logger
    #
    # The worker actually serves the client
    # Workers take a client from the supervisor (pull based)
    # and send messages to logger when non-ractor exceptions are raised (push based)
    #
    # Termination:
    # Workers do not stop while the supervisor is alive unless explicitly told to
    def make_worker: (Proc serve_proc, Hash[untyped, untyped] worker_resources, ?name: ::String) -> Ractor

    # Create a supervisor Ractor
    #
    # supervisor >---- worker
    #          |-----> logger
    #
    # The supervisor dispatches clients for the workers to take on
    # Supervisor safely terminates on receiving TerminateServer error.
    # This will be triggered remotely by the main thread on the main ractor.
    # Graceful termination will safely join with workers and logger.
    # Assuming no workers or the logger is blocking, graceful termination guarantees
    # joining with all child ractors. This is becausee workers are guaranteed to
    # survive as long as the supervisor too is alive and well.
    #
    # Termination:
    # Any other error will trigger a "non-graceful" termination.
    # We do not know if any child ractors are in a blocking state, so we cannot
    # yield or take from any of them without risk of blocking the supervisor.
    # So, the supervisor does not attempt to join.
    def make_supervisor: () -> Thread

    # Resources to be passed to the worker. All values must be shareable or made
    # shareable. The default server doesn't pass anything additional to the worker
    def worker_resources: () -> Hash[untyped, untyped]
  end
end
